<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"autzoko.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="JavaScript高频问题  JS的组成部分  ECMA Script：JS的核心内容，基础语法。如var, for, 数据类型等。 文档对象模型（DOM）：DOM将HTML页面规划为元素构成的文档。 浏览器对象模型（BOM）：对浏览器窗口进行访问和操作（如提供浏览器特性，获取浏览器API）。  JS内置对象  String, Boolean, Number, Array, Object, Fu">
<meta property="og:type" content="article">
<meta property="og:title" content="前端八股（JS部分）">
<meta property="og:url" content="https://autzoko.github.io/2025/08/24/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%EF%BC%88JS%E9%83%A8%E5%88%86%EF%BC%89/index.html">
<meta property="og:site_name" content="Blog | Autzoko Lang">
<meta property="og:description" content="JavaScript高频问题  JS的组成部分  ECMA Script：JS的核心内容，基础语法。如var, for, 数据类型等。 文档对象模型（DOM）：DOM将HTML页面规划为元素构成的文档。 浏览器对象模型（BOM）：对浏览器窗口进行访问和操作（如提供浏览器特性，获取浏览器API）。  JS内置对象  String, Boolean, Number, Array, Object, Fu">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-08-24T05:05:37.000Z">
<meta property="article:modified_time" content="2025-08-25T06:05:31.910Z">
<meta property="article:author" content="Autzoko Lang">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="八股">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://autzoko.github.io/2025/08/24/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%EF%BC%88JS%E9%83%A8%E5%88%86%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>前端八股（JS部分） | Blog | Autzoko Lang</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog | Autzoko Lang</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">THIS IS MY KINGDOM COME</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://autzoko.github.io/2025/08/24/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%EF%BC%88JS%E9%83%A8%E5%88%86%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Autzoko Lang">
      <meta itemprop="description" content="Crescat Scientia Vita Excolatur">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog | Autzoko Lang">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          前端八股（JS部分）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-24 13:05:37" itemprop="dateCreated datePublished" datetime="2025-08-24T13:05:37+08:00">2025-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-25 14:05:31" itemprop="dateModified" datetime="2025-08-25T14:05:31+08:00">2025-08-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AE%9E%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">实习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AE%9E%E4%B9%A0/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">前端八股</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="javascript高频问题">JavaScript高频问题</h2>
<ol type="1">
<li>JS的组成部分
<ul>
<li>ECMA Script：JS的核心内容，基础语法。如<code>var</code>,
<code>for</code>, 数据类型等。</li>
<li>文档对象模型（DOM）：DOM将HTML页面规划为<strong>元素</strong>构成的文档。</li>
<li>浏览器对象模型（BOM）：对浏览器窗口进行访问和操作（如提供浏览器特性，获取浏览器API）。</li>
</ul></li>
<li>JS内置对象
<ul>
<li><code>String, Boolean, Number, Array, Object, Function, Math, Date, RegExp</code>…</li>
<li>常用内置对象：
<ul>
<li><code>Math: abs(), sqrt(), max(), min(), ...</code></li>
<li><code>Date: new Date(), getYear(), getHour(), ...</code></li>
<li><code>String: concat(), length, slice(), split(), ...</code></li>
</ul></li>
</ul></li>
<li>操作数组的方法
<ul>
<li><code>push(), pop(), sort(), shift(), unshift(), reverse(), concat(), join(), map(), filter, every(), some(), reduce(), isArray(), findIndex(), splice()</code></li>
<li>哪些方法会改变原数组：<code>push(), pop(), shift(), unshift(), sort(), reverse(), splice()</code></li>
</ul></li>
<li>检测数据类型
<ul>
<li><code>typeof</code>：判断基础数据类型，无法判断引用数据类型（class）。<code>typeof 12345</code></li>
<li><code>instanceof()</code>：只能判断引用数据类型，无法判断基本数据类型。<code>[] instanceof Array</code></li>
<li><code>constructor</code>：几乎可以判断基本数据类型和引用数据类型。<code>('abc').constructor === String</code></li>
<li><code>Object.prototype.toString.call()</code>：解决以上方式的问题。<code>Object.prototype.toString.call(2/'abc'/true/[]/&#123;&#125;)</code></li>
</ul></li>
<li>闭包特性
<ul>
<li>函数嵌套函数，内部函数被外部函数返回并保存下来时会产生闭包。
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">param</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(param);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="title function_">fn</span>(<span class="string">&#x27;abcd&#x27;</span>);</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure> 输出<code>abcd</code>。</li>
<li>特性：
<ul>
<li>可以复用变量且该变量不会污染全局（变量始终保存在内存中，不会被垃圾回收机制回收）。</li>
<li>缺点：闭包较多时对内存占用较多，导致页面性能下降。只有在IE浏览器中会导致内存泄露。</li>
</ul></li>
<li>使用场景：防抖、节流、需避免全局污染时。</li>
</ul></li>
<li>前端内存泄漏
<ul>
<li>JS中已分配内存空间的对象为能及时释放清除，会导致长期占用内存的现象，导致内存资源可用性变差，最终导致运行效率降低，甚至内存泄漏。</li>
<li>JS的垃圾回收机制：自动释放长时间不用的内存资源。</li>
<li>导致内存泄漏的原因：为声明直接赋值的变量、未清空的定时器、过度闭包、引用元素未被清除等。</li>
</ul></li>
<li>事件委托（事件代理）
<ul>
<li>利用事件冒泡机制，将子元素事件（event）绑定到父元素上。</li>
<li>若子元素阻止事件冒泡(<code>event.stop()</code>)，则委托不成立。</li>
<li><code>addEventListener('click', func_name, false)</code>默认false，false控制事件冒泡，true为事件捕获。</li>
<li>好处：提高性能，减少事件绑定，减少内存占用。</li>
</ul></li>
<li>基本数据类型与引用数据类型
<ul>
<li>基本数据类型：<code>String, Number, Boolean, undefined, null</code>等保存在<strong>栈</strong>中，直接保存数据。</li>
<li>引用数据类型（复杂数据类型）：<code>Object, Function, Array</code>等保存在<strong>堆</strong>中，类似于C语言的指针类型（或C++引用），保存引用数据类型的地址。加入声明两个引用类型变量引用同一个地址时，改变其中一个另一个也改变。</li>
</ul></li>
<li>原型链
<ul>
<li>原型就是一个普通对象，用于构造函数的实例，共享属性和方法；所有实例中引用的原型都是同一个对象。
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p1.<span class="title function_">say</span>(); <span class="comment">//p1和p2的say方法相互独立，需要存两个实例。</span></span><br><span class="line">p2.<span class="title function_">say</span>();</span><br></pre></td></tr></table></figure></li>
<li>使用prototype可以把方法挂在原型上，不同实例共享同一内存。
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">look</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Look&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">p1.<span class="title function_">look</span>();<span class="comment">//p1和p2的look方法指向同一内存。</span></span><br><span class="line">p2.<span class="title function_">look</span>();</span><br></pre></td></tr></table></figure></li>
<li><code>__proto__</code>可以理解为指针，实例对象中的属性指向构造函数的原型（prototype）。</li>
<li><strong>参照C++虚函数表机制。</strong></li>
<li>JS中若把属性定义在Prototype上，只读时内存共享，一旦需要写入则创建拷贝（遮蔽）。</li>
<li>原型链：一个实例对象在调用属性、方法时一次按照<strong>实例本身(<code>Person</code>)、构造函数原型(<code>Person.prototype</code>)、原型的原型(<code>Object.prototype</code>)</strong>上去查找。</li>
</ul></li>
<li><code>new</code>操作符
<ol type="1">
<li>创建空对象。</li>
<li>把空对象和构造函数通过原型链连接。</li>
<li>把构造函数的<code>this</code>绑定到新的空对象。</li>
<li>根据构造函数返回的类型判断，若为值则返回对象值，若为引用则返回引用。</li>
</ol></li>
<li>JS的继承机制
<ul>
<li>原型链继承：方便简洁，容易理解；对象实例继承所有属性和方法，无法像父类构造函数传参。<code>Child.prototype = new Parent()</code></li>
<li>借用构造函数继承：在子类构造函数内部调用父类构造函数；使用<code>apply()</code>或<code>call()</code>方法将父对象构造函数绑定在子对象上。在子类中写<code>Parent.call(this, param)</code>。解决了原型链实现继承无法向父类传参的问题；方法都在构造函数中定义，无法实现函数复用，且父类原型中定义的方法对子类不可见，所有类型只能使用构造函数模式。</li>
<li>组合式继承：解决了原型链继承和构造函数继承的缺点；然而无论什么情况下都会调用两次父类构造函数（一次是创建子类原型时，另一次在子类构造函数内部）。</li>
<li>ES6的class类继承：Class通过<code>extends</code>关键字实现继承，实质是先创造出父类this对象在调用子类构造函数修改this。子类构造方法中必须调用super方法且只有在调用了super后才能使用this。简单易懂；对于不支持ES6的浏览器无法适用。</li>
</ul></li>
<li>JS的设计原理
<ul>
<li>JS引擎：编译器。</li>
<li>运行上下文：浏览器中可调用的API（外部接口）。</li>
<li>调用栈：函数调用顺序的数据结构。用于同步执行、递归、错误堆栈等场景。（JS是单线程，只有一个主线程）</li>
<li>事件循环：由于JS是单线程，为防止卡死引入了<strong>异步</strong>机制。事件循环为调用栈为空时，从任务队列里取出一个回调，压入调用栈执行，重复这个过程。把耗时任务交给“外部系统
(浏览器内核的 Web APIs 或 Node 的 libuv)”，等结果好了，再通过 事件循环
(Event Loop) 安排执行回调函数。</li>
<li>回调：是一个被当作参数传递的函数，在合适的时候被调用。在异步编程里，回调通常是“异步任务完成后要执行的代码”。</li>
</ul></li>
<li>JS中this的指向
<ul>
<li>全局对象中<code>this</code>的指向：指向window。</li>
<li>全局作用域或普通函数中的<code>this</code>：指向window。</li>
<li><code>this</code>永远指向最后调用它的对象。（非箭头函数）</li>
<li><code>new</code>关键词会改变this的指向。</li>
<li><code>apply</code>，<code>call</code>以及<code>bind</code>都可以改变<code>this</code>的指向。（非箭头函数）</li>
<li>箭头函数中的<code>this</code>在定义时已被确定，箭头函数无this，看外层是否有函数，有就是外层函数的this，没有就是window。</li>
<li>匿名函数中<code>this</code>永远指向window。（匿名函数的执行环境具有全局性）。</li>
</ul></li>
<li>Script标签中<code>async</code>与<code>defer</code>
<ul>
<li>没有async与defer时：浏览器会立刻加载并执行指定的脚本。</li>
<li>有<code>async</code>：加载和渲染后面元素的过程将与Script的加载和执行并行执行（异步）。</li>
<li>有<code>defer</code>：加载Script与加载渲染元素异步完层，执行则在所有元素解析完成之后。</li>
</ul></li>
<li><code>setTimeout</code>的最小执行时间
<ul>
<li>setTimeout：4ms</li>
<li>setInterval： 10ms</li>
<li>由HTML5规定（浏览器可能会影响）</li>
</ul></li>
<li>ES6和ES5的区别
<ul>
<li>ES5: ECMA Script 5（ECMAScript2009）；</li>
<li>ES6: ECMA Script 6（ECMAScript2015）；</li>
</ul></li>
<li>ES6的新特性
<ul>
<li>新增块级作用域（let，const）
<ul>
<li>不能在同一个作用域内重复声明。</li>
<li>不存在变量提升。</li>
<li>存在暂时性死区问题</li>
</ul></li>
<li>新增定义类（class）</li>
<li>新增一种数据类型（symbol）：代表独一无二的值，即使内容一致。</li>
<li>新增结构赋值：从数据或者对象中取值赋给变量。</li>
<li>新增函数参数默认值</li>
<li>新增数组API</li>
<li>新增对象和数组的扩展运算符</li>
<li>新增Promise
<ul>
<li>表示未来才会完成的值，用于解决回调地狱的问题。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;任务完成&quot;</span>); <span class="comment">// 或 reject(&quot;出错了&quot;)</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    p.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>自身有all，reject，resolve，rece这些方法。原型上有then，catch方法。</li>
<li>把异步操作序列话，按预期返回结果。</li>
<li>三种状态：pending（初始），fulfilled（操作成功），rejected（操作失败）。一旦状态转变就会凝固。</li>
<li>async与await：同步代码做异步操作，必须搭配使用。是Promise的语法糖。在函数面前添加async会自动返回一个Promise。遇到await暂停执行，等待Promise完成再继续。</li>
</ul></li>
<li>新增模块化（import，export）</li>
<li>新增set和map数据结构</li>
<li>新增generator</li>
<li>新增箭头函数
<ul>
<li>不能作为构造函数使用，不能用new。</li>
<li>箭头函数没有arguments。</li>
<li>不能使用call，apply，bind去改变this的执行</li>
<li>无prototype。</li>
</ul></li>
</ul></li>
<li><code>call, apply, bind</code>的区别
<ul>
<li>都是改变this指向和函数调用。</li>
<li>call与apply类似，只是传参方法不同。</li>
<li>call传参数列表。</li>
<li>apply传一个数组。</li>
<li>bind传参后不会立即执行，会返回一个改变了this指向的函数，这个函数可传参，通过<code>bind()()</code>来调用。</li>
<li>call方法性能比apply好一些，bind无法构造函数。</li>
</ul></li>
<li>递归的问题
<ul>
<li>递归：函数内部调用函数本身（递归函数必须有退出条件，否则会导致栈溢出）。</li>
</ul></li>
<li>深拷贝的实现
<ul>
<li>完全拷贝一个新的对象，在堆中重新开辟新的空间。拷贝的对象被修改后，原对象不受影响。</li>
<li>主要针对引用数据类型。</li>
<li>扩展运算符：只能针对第一层深拷贝，对于多层对象只是浅拷贝。
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;...obj&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>JSON.parse(JSON.stringify())</code>：原对象中若有函数则不会被拷贝过来。</li>
<li>利用递归函数： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">copy</span>(<span class="params">origin, isDeepCopy=<span class="literal">true</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (origin <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">        result = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> origin) &#123;</span><br><span class="line">        <span class="keyword">let</span> v = origin[key];</span><br><span class="line">        result[key] = (!!isDeepCopy &amp;&amp; <span class="keyword">typeof</span> v === <span class="string">&#x27;object&#x27;</span> &amp;&amp; v !== <span class="literal">null</span>) ? <span class="title function_">copy</span>(v, isDeepCopy) : v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>事件循环
<ul>
<li>JS是一个单线程脚本语言。</li>
<li>主线程：唯一线程上任务。</li>
<li>执行栈：任务栈，存储上下文与执行顺序。</li>
<li>任务队列：任务调度。</li>
<li>宏任务/微任务：异步任务，微任务优先级更高。</li>
<li>主线程先执行同步任务，再执行任务队列里的微任务或宏任务。执行完再去查询任务队列，或者执行主任务。</li>
</ul></li>
<li>AJAX
<ul>
<li>创建交互式网页应用的开发技术，再不重新加载整个页面的情况下与服务器交换数据并更新部分内容。</li>
<li>通过XMLHttpRequest对象向服务器发送异步请求，返回数据后通过JS操作DOM的形式更新页面。</li>
<li>过程：
<ul>
<li>创建XMLHttpRequest对象。</li>
<li>通过XMH对象里的open()方法与服务器建立连接。</li>
<li>构建请求所需的数据，并通过XMH的send()方法发送至服务器。</li>
<li>通过XMH对象的onReadyStateChange事件监听服务器与本地的通信状态。</li>
<li>接受并处理服务器响应的结果。</li>
<li>将处理结果更新到HTML页面中。</li>
</ul></li>
</ul></li>
<li><code>GET</code>与<code>POST</code>的区别
<ul>
<li>GET一般获取数据，POST一般提交数据。</li>
<li>GET参数在URL中，安全性较差。</li>
<li>POST参数在body中，数据长度无限制。</li>
<li>GET请求刷新服务器或退回无影响，POST请求退回时重新提交数据。</li>
<li>GET请求会被缓存，POST不会。</li>
<li>GET会被保存在浏览器的历史记录中，POST不会。</li>
<li>GET只能进行url编码，POST支持多种数据结构。</li>
</ul></li>
<li>Promise的内部原理与优缺点
<ul>
<li>Promise对象封装了一个异步操作且可以获取成功或失败的结果。</li>
<li>Promise主要解决回调地狱的问题，若之前异步任务较多且之间包含依赖关系就只能用回调函数解决，这样会导致代码可读性差、可维护性差形成了回调地狱。</li>
<li>Promise的三种状态：Pending，Fulfilled，Rejected。只能从Pending变为后者其中之一且不可逆。</li>
<li>Promise无法被取消，一旦创建立即执行，无法中断。</li>
<li>如果不设置回调，Promise内部抛出的错误无法反馈到外面。</li>
<li>原理：
<ul>
<li>构造一个Promise实例需要传递一个函数作为参数，该函数有两个形参切都是函数类型，一个是resolve另一个是reject。</li>
<li>Promise上还有then方法，用来指定状态发生改变时的确定操作，resolve执行第一个函数，reject执行第二个函数。</li>
</ul></li>
</ul></li>
<li>Promise与async、await的区别
<ul>
<li>都是异步处理请求方式。</li>
<li>Promise是ES6，async和await是ES7.</li>
<li>async与await都是基于Promise实现的，都是非阻塞的。</li>
<li>优缺点：
<ul>
<li>Promise是一个返回对象需要用then和catch来捕获，且书写方式是链式的容易造成代码重叠不好维护。而async和await通过try-catch来捕获异常。</li>
<li>async
await最大的优点是让代码看起来像同步一样，只要遇到await就会立刻返回结果然后再执行后面的操作。而Promise.then()的方式会出现请求还没返回就执行了后面操作的情况。</li>
</ul></li>
</ul></li>
<li>浏览器的存储方式
<ul>
<li>cookies：H5标准前的本地存储方式；兼容性好，请求头自带cookie；存储量小容易造成资源浪费，使用麻烦（需要封装）。</li>
<li>localStorage：H5加入的标准方式，以key-value的形式存储。操作方便、永久存储、兼容性好；保存值的类型可能被限定，浏览器隐私模式下不可读取，不能被爬虫。</li>
<li>sessionStorage：类似于localStorage；当前页面关闭后会被立即清理，会话级别的存储方式。</li>
<li>indexedDB：H5标准存储方式，key-value存储，可以快速读取，适合web场景。</li>
</ul></li>
<li>token的存储位置
<ul>
<li>token：验证身份的令牌，一般是用户通过账号密码登录后，服务端把这些凭证通过加密等一系列操作后得到的字符串。</li>
<li>若存在localStorage里，后期每次请求接口都需要把它当作一个字段传给后台，容易被XSS攻击。</li>
<li>若存在cookie中会自动发送，不能跨域，会有CSRF攻击。</li>
<li>一般存在localStorage/sessionStorage中，具体看需求。</li>
</ul></li>
<li>token的登录流程
<ol type="1">
<li>客户端用账号密码请求登录。</li>
<li>服务端收到请求后验证账号密码。</li>
<li>验证成功后，服务端签发一个token发送给客户端。</li>
<li>客户端收到token保存后。</li>
<li>后续客户端每次向服务端发送资源请求时，都需要携带这个token。</li>
<li>服务端收到请求后验证token。成功则返回资源。</li>
</ol></li>
<li>页面渲染的过程
<ul>
<li>DNS解析-建立TCP连接-发送HTTP请求-服务端处理请求-渲染页面-断开TCP</li>
<li>渲染页面：
<ul>
<li>获取HTML和CSS资源，把HTML解析成DOM树。</li>
<li>解析CSS为CSSOM。</li>
<li>把DOM和CSSOM合并为渲染树。</li>
<li>把渲染树每个节点渲染到页面上（绘制）。</li>
</ul></li>
</ul></li>
<li>DOM树与渲染树
<ul>
<li>DOM树是HTML标签的一一对应，包括head和隐藏元素。</li>
<li>渲染树不包含head和隐藏元素。</li>
</ul></li>
<li>精灵图与base64
<ul>
<li>精灵图：多张图拼接后压缩，前端若要请求多张图片可以只请求一次。</li>
<li>base64：单张图片二进制信息转译为字符串（字符串大小可能比原图大）。</li>
</ul></li>
<li>svg格式
<ul>
<li>基于XML语法格式的图像格式，可缩放矢量图。</li>
<li>svg可直接插入页面中，用JS或css对其进行操作。<code>&lt;svg&gt;&lt;/svg&gt;</code></li>
<li>也可以作为图像文件被引入。</li>
<li>可以转为base64引入。</li>
</ul></li>
<li>JWT
<ul>
<li>JSON Web
Token通过JSON形式在web应用中的令牌，可以在各方之间安全的把信息作为JSON对象传输。</li>
<li>用作信息传输、授权。</li>
<li>如果用session来验证会导致服务端负载过大，不利于负载均衡。</li>
<li>JWT认证流程：
<ul>
<li>前端把账号密码发送给后端接口。</li>
<li>后端核对信息，把用户id等信息作为JWT负载，把它和head分别进行base64编码后拼接的签名，形成一个JWT
Token。</li>
<li>前端每次请求时都会把JWT放在请求头的Authorization位置。</li>
<li>后端检查是否存在，如果存在就验证JWT的有效性（签名是否正确，token是否过期等）。</li>
<li>验证后后端使用JWT中包含的用户信息进行其他的操作，并返回对应结果。</li>
</ul></li>
<li>JWT简洁、可跨语言使用。</li>
</ul></li>
<li>npm的底层环境
<ul>
<li>node package
manager，node的包管理和分发工具，已经成为分发node的标准。是JS的运行环境。</li>
<li>组成：网站、注册表（每一个包基本信息的数据库），命令行工具。</li>
</ul></li>
<li>HTTP协议规定包含的响应头和请求头
<ul>
<li>请求头信息：
<ul>
<li>Accept：浏览器告诉服务器所支持的数据类型。</li>
<li>Host：浏览器告诉服务器像访问的主机。</li>
<li>Referer：浏览器告诉服务器我从哪里来（防盗链）。</li>
<li>User-Agent：浏览器类型、版本。</li>
<li>Date：浏览器告诉服务器我是什么时候访问的。</li>
<li>Connection：连接方式。</li>
<li>Cookie</li>
<li>X-Request-With：请求方式。</li>
</ul></li>
<li>响应头信息：
<ul>
<li>Location：告诉浏览器你要去找谁。</li>
<li>Server：告诉浏览器服务器的类型。</li>
<li>Content-Type：告诉浏览器返回的数据类型。</li>
<li>Refresh：控制定时刷新。</li>
</ul></li>
</ul></li>
<li>浏览器的缓存策略
<ul>
<li>强缓存（本地缓存）：不发起请求，直接使用缓存中的内容，浏览器把JS，CSS，image等内容存到内存中，下次访问时直接从内存中取。</li>
<li>弱缓存（协商缓存）：需要向后台发请求，通过判断来决定是否使用协商缓存，如果请求内容没有变化，则返回304，浏览器使用缓存里的内容。</li>
<li>强缓存的触发：HTTP1.0用时间戳响应标头；HTTP1.1用Cache-Control响应标头。</li>
<li>弱缓存的触发：HTTP1.0用if-modified-since响应头last-modified；HTTP1.1用if-none-match响应头Etag。</li>
</ul></li>
<li>同源策略
<ul>
<li>浏览器的基本（核心）安全策略，URL中协议、域名以及端口号完全相同即为同源。不一样则产生跨域。</li>
<li>三个允许跨域加载资源的标签：img，link，script。</li>
<li>跨域是可以正常发送请求的，后端也会返回结果，只不过该结果被浏览器拦截。</li>
<li>解决跨域的方式：JSONP（服务端允许），CORS（服务端和客户端同时配置），websocket，反向代理（中转站）。</li>
</ul></li>
<li>防抖和节流
<ul>
<li>都是应对页面中频繁触发事件的优化方案。</li>
<li>防抖：触发事件后，在一段时间内只执行最后一次。如果在这段时间内事件又被触发，就重新计时。
<ul>
<li>频繁和服务端交互</li>
<li>输入框自动保存时间</li>
</ul></li>
<li>节流：触发事件后，在固定时间间隔内只执行一次。不管事件触发多少次，都会按照时间间隔来执行。
<ul>
<li>页面滚动监听 → 每 200ms 计算一次位置。</li>
<li>鼠标拖拽 → 每 100ms 更新一次位置。</li>
</ul></li>
</ul></li>
<li>JSON
<ul>
<li>JSON是纯字符串形式数据，适合在网络中传输，不提供任何方法。</li>
<li>JSON数据存储在.json文件中，或者以字符串形式在数据库、cookie中。</li>
<li>JS提供了<code>JSON.parse()</code>,
<code>JSON.stringify()</code>方法。</li>
<li>使用场景：定义接口、序列化、生成token、配置文件。</li>
</ul></li>
<li>数据请求失败的做法
<ul>
<li>在渲染数据的地方给默认值。</li>
<li>if判断，没有数据可以隐藏。</li>
</ul></li>
<li>无感登录
<ul>
<li>无感刷新token，token失效时自动更新。</li>
<li>在响应拦截器中拦截，token过期后调用刷新token的接口。（常用）</li>
<li>后端返回过期的时间，前端判断token的过期时间，主动调用刷新token的接口。</li>
<li>写定时器，定时刷新token。</li>
<li>流程：
<ul>
<li>登录成功后保存token和refresh_token。</li>
<li>响应拦截器中对401状态码引入刷新token的api方法调用。</li>
<li>替换保存本地新的token。</li>
<li>把错误对象里的token替换。</li>
<li>再次发送未完成请求。</li>
<li>如果refresh_token也过期，清除所有token返回登录页面。</li>
</ul></li>
</ul></li>
<li>大文件上传
<ul>
<li>分片上传：把需要上传的文件按一定规则分割成大小相同的数据块。
<ul>
<li>初始化分片上传任务，返回本次上传的唯一标识。</li>
<li>按照一定规则把各个数据块上传。</li>
<li>发送完成后服务端判断数据完整性，若完整则合并。</li>
</ul></li>
<li>断点续传：
<ul>
<li>服务端返回从哪里开始/浏览器自己处理。</li>
</ul></li>
</ul></li>
<li><code>var</code>，<code>let</code>与<code>const</code>的区别
<ul>
<li>作用域：
<ul>
<li>var在函数内声明则只作用于函数内部，其他情况都是全局作用域。</li>
<li>let/const是在花括号内有效。</li>
</ul></li>
<li>变量提升：
<ul>
<li>var声明会被提升（hoist），初始化为undefined。声明之前访问为undefined。</li>
<li>let/const也会被提升，但是会有TDZ（Temporary Dead
Zone），在声明之前访问会报错。</li>
</ul></li>
<li>重复声明：
<ul>
<li>var可以重复声明同名变量。</li>
<li>let/const在同一作用域内不允许重复声明。</li>
</ul></li>
<li>是否可以重新赋值：
<ul>
<li>var/let：可以重新赋值。</li>
<li>const：声明后必须立刻赋初值，且不能重复赋值。</li>
</ul></li>
<li>对象/数据的const特殊性：const只是保证变量绑定（引用）不可辨，但对象/数组的内容可以被改变。</li>
</ul></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag"># 前端</a>
              <a href="/tags/%E5%85%AB%E8%82%A1/" rel="tag"># 八股</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/08/23/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%EF%BC%88CSS%E9%83%A8%E5%88%86%EF%BC%89/" rel="prev" title="前端八股（CSS部分）">
      <i class="fa fa-chevron-left"></i> 前端八股（CSS部分）
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/08/25/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%EF%BC%88HTML5-CSS3%E9%83%A8%E5%88%86%EF%BC%89/" rel="next" title="前端八股（HTML5-CSS3部分）">
      前端八股（HTML5-CSS3部分） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#javascript%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">JavaScript高频问题</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Autzoko Lang"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Autzoko Lang</p>
  <div class="site-description" itemprop="description">Crescat Scientia Vita Excolatur</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Autzoko" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Autzoko" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/langtian0725@gmail.com" title="E-Mail → langtian0725@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/autzoko" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;autzoko" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://linkedin.com/in/langtian-lang" title="LinkedIn → https:&#x2F;&#x2F;linkedin.com&#x2F;in&#x2F;langtian-lang" rel="noopener" target="_blank"><i class="fab fa-linkedin fa-fw"></i>LinkedIn</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Autzoko Lang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
